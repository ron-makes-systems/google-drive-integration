# Google Drive API integration guide for Fibery

The Google Drive API v3 provides comprehensive access to **personal drives, shared drives, files, folders, and user permissions** needed for a production Fibery integration. This guide covers OAuth2 authentication, all four entity types (Drive, Folder, File, User), content extraction from Google Workspace files, and critical implementation details including rate limits, pagination, and incremental sync strategies.

## OAuth2 authentication implementation

Google Drive requires OAuth2 with careful scope selection. For a read-only sync integration, request the **restricted** `drive.readonly` scope, which requires Google's verification process including a security assessment for production apps storing user data.

### Authorization flow

```javascript
const { google } = require('googleapis');

const oauth2Client = new google.auth.OAuth2(
  process.env.CLIENT_ID,
  process.env.CLIENT_SECRET,
  process.env.REDIRECT_URI
);

// Generate authorization URL
const authUrl = oauth2Client.generateAuthUrl({
  access_type: 'offline',           // Required for refresh tokens
  scope: [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile'
  ],
  include_granted_scopes: true,
  prompt: 'consent'                 // Forces refresh token on each auth
});

// Exchange code for tokens (after user consent)
const { tokens } = await oauth2Client.getToken(authorizationCode);
oauth2Client.setCredentials(tokens);
// tokens: { access_token, refresh_token, expiry_date, token_type }

// Auto-refresh handling
oauth2Client.on('tokens', (newTokens) => {
  if (newTokens.refresh_token) {
    saveRefreshToken(newTokens.refresh_token); // Store encrypted
  }
});
```

### Scope selection matrix

| Scope | Access Level | Verification |
|-------|--------------|--------------|
| `drive.readonly` | Read all files/folders | **Restricted** - requires security assessment |
| `drive.metadata.readonly` | Metadata only (no content) | **Restricted** |
| `drive.file` | Only app-created/opened files | Non-sensitive |
| `drive` | Full read/write | **Restricted** |

**Token limits**: Google allows **100 refresh tokens** per user per OAuth client. Store tokens encrypted at rest and handle `invalid_grant` errors by prompting re-authorization.

## Drive entity: My Drive and Shared Drives

The API treats personal and shared drives differently. **"My Drive" has no dedicated drive resource**—it's accessed through the files API with special handling. Shared drives have their own `drives` resource.

### Listing shared drives

```javascript
const drive = google.drive({ version: 'v3', auth: oauth2Client });

async function listAllSharedDrives() {
  const allDrives = [];
  let pageToken = null;
  
  do {
    const response = await drive.drives.list({
      pageSize: 100,
      pageToken,
      fields: 'nextPageToken, drives(id, name, colorRgb, createdTime, capabilities, restrictions)'
    });
    
    allDrives.push(...(response.data.drives || []));
    pageToken = response.data.nextPageToken;
  } while (pageToken);
  
  return allDrives;
}
```

### Shared drive metadata fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Drive ID (**same as root folder ID**) |
| `name` | string | Drive name |
| `colorRgb` | string | Hex color code |
| `createdTime` | RFC 3339 | Creation timestamp |
| `capabilities` | object | Boolean flags for allowed operations |
| `restrictions` | object | Sharing/copy restrictions |
| `hidden` | boolean | Hidden from default view |
| `orgUnitId` | string | Organizational unit (admin access only) |

**Critical insight**: The shared drive's `id` equals its root folder ID—use this when querying files within a specific shared drive.

### Representing My Drive

Since My Drive lacks a drive resource, represent it as a synthetic entity:

```javascript
// Get My Drive root folder info
const rootInfo = await drive.files.get({
  fileId: 'root',
  fields: 'id, name'
});

const myDriveEntity = {
  id: rootInfo.data.id,
  name: 'My Drive',
  type: 'personal',
  isMyDrive: true
};
```

### Filtering drives for sync

Allow users to select which drives to sync by presenting both personal and shared options:

```javascript
async function getAvailableDrivesForSync() {
  // Personal drive
  const drives = [{
    id: 'root',
    name: 'My Drive',
    type: 'personal'
  }];
  
  // Shared drives
  const sharedDrives = await listAllSharedDrives();
  sharedDrives.forEach(sd => {
    drives.push({
      id: sd.id,
      name: sd.name,
      type: 'shared',
      colorRgb: sd.colorRgb
    });
  });
  
  return drives;
}
```

## Folder entity: hierarchy and metadata

Folders use the same `files` resource with MIME type `application/vnd.google-apps.folder`. The parent-child relationship is stored in the `parents[]` array on each file/folder.

### Listing folders in a specific location

```javascript
async function listFolders(parentId, driveId = null) {
  const params = {
    q: `'${parentId}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false`,
    supportsAllDrives: true,
    includeItemsFromAllDrives: true,
    fields: 'nextPageToken, files(id, name, parents, createdTime, modifiedTime, webViewLink, permissions, capabilities)',
    pageSize: 1000
  };
  
  // Scope to specific shared drive for efficiency
  if (driveId) {
    params.corpora = 'drive';
    params.driveId = driveId;
  }
  
  const response = await drive.files.list(params);
  return response.data.files;
}
```

### Building folder hierarchy

Since files know their parents (not children), build the tree by indexing:

```javascript
async function buildFolderTree(driveId) {
  // Fetch all folders
  const folders = await listAllFolders(driveId);
  
  // Create lookup map
  const folderMap = new Map();
  folders.forEach(f => folderMap.set(f.id, { ...f, children: [] }));
  
  // Build tree
  const rootFolders = [];
  folders.forEach(folder => {
    if (folder.parents && folder.parents[0]) {
      const parent = folderMap.get(folder.parents[0]);
      if (parent) parent.children.push(folderMap.get(folder.id));
      else rootFolders.push(folderMap.get(folder.id));
    } else {
      rootFolders.push(folderMap.get(folder.id));
    }
  });
  
  return rootFolders;
}
```

### Folder metadata fields for Fibery sync

| Field | Description | Sync Priority |
|-------|-------------|---------------|
| `id` | Unique identifier | Required |
| `name` | Folder name | Required |
| `parents[]` | Parent folder ID(s) | Required for hierarchy |
| `webViewLink` | Google Drive URL | High |
| `createdTime` | Creation timestamp | Medium |
| `modifiedTime` | Last modification | Required for delta sync |
| `driveId` | Containing shared drive | Required |
| `capabilities` | Allowed operations | Medium |
| `permissions[]` | Access permissions | Optional |

## File entity: comprehensive metadata

The files resource provides **50+ metadata fields**. Request only needed fields using the `fields` parameter to reduce payload size and improve performance.

### Essential file metadata request

```javascript
async function getFileMetadata(fileId) {
  const response = await drive.files.get({
    fileId,
    supportsAllDrives: true,
    fields: `
      id, name, mimeType, description,
      createdTime, modifiedTime, viewedByMeTime,
      size, quotaBytesUsed,
      webViewLink, webContentLink, iconLink, thumbnailLink,
      parents, driveId,
      owners, lastModifyingUser, sharingUser,
      permissions, shared,
      version, headRevisionId,
      capabilities,
      trashed, trashedTime,
      md5Checksum, exportLinks
    `.replace(/\s+/g, '')
  });
  return response.data;
}
```

### Complete file metadata reference

**Core identifiers and timestamps:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique file identifier |
| `name` | string | File name |
| `mimeType` | string | MIME type |
| `createdTime` | RFC 3339 | Creation time |
| `modifiedTime` | RFC 3339 | Last modification (any user) |
| `viewedByMeTime` | RFC 3339 | Last viewed by current user |
| `sharedWithMeTime` | RFC 3339 | When shared with current user |

**URLs and links:**

| Field | Type | Description |
|-------|------|-------------|
| `webViewLink` | string | Opens file in Google editor/viewer |
| `webContentLink` | string | Direct download link (binary files) |
| `iconLink` | string | Static icon URL |
| `thumbnailLink` | string | Short-lived thumbnail URL |
| `exportLinks` | object | Export URLs by format (Workspace files) |

**Ownership and sharing:**

| Field | Type | Description |
|-------|------|-------------|
| `owners[]` | User[] | File owners (empty for shared drive files) |
| `lastModifyingUser` | User | Last modifier |
| `sharingUser` | User | Who shared with current user |
| `shared` | boolean | Whether file has been shared |
| `permissions[]` | Permission[] | All permissions on file |

### Listing files with filtering

```javascript
async function listFilesWithFilters(options = {}) {
  const queryParts = ['trashed = false'];
  
  if (options.folderId) {
    queryParts.push(`'${options.folderId}' in parents`);
  }
  if (options.mimeType) {
    queryParts.push(`mimeType = '${options.mimeType}'`);
  }
  if (options.modifiedAfter) {
    queryParts.push(`modifiedTime > '${options.modifiedAfter}'`);
  }
  if (options.nameContains) {
    queryParts.push(`name contains '${options.nameContains}'`);
  }
  
  const params = {
    q: queryParts.join(' and '),
    pageSize: 1000,
    orderBy: 'modifiedTime desc',
    supportsAllDrives: true,
    includeItemsFromAllDrives: true,
    fields: 'nextPageToken, files(id, name, mimeType, modifiedTime, parents, webViewLink, owners)'
  };
  
  // Scope to specific drive for user filtering
  if (options.driveId && options.driveId !== 'root') {
    params.corpora = 'drive';
    params.driveId = options.driveId;
  }
  
  return await paginateAll(params);
}
```

### Query syntax reference

| Term | Operators | Example |
|------|-----------|---------|
| `name` | `=`, `!=`, `contains` | `name contains 'Budget'` |
| `mimeType` | `=`, `!=` | `mimeType = 'application/pdf'` |
| `modifiedTime` | `<`, `<=`, `>`, `>=` | `modifiedTime > '2025-01-01'` |
| `parents` | `in` | `'folderId' in parents` |
| `owners` | `in` | `'user@example.com' in owners` |
| `trashed` | `=`, `!=` | `trashed = false` |
| `fullText` | `contains` | `fullText contains 'quarterly'` |

### File revisions

```javascript
async function getFileRevisions(fileId) {
  const response = await drive.revisions.list({
    fileId,
    fields: 'revisions(id, mimeType, modifiedTime, lastModifyingUser, size, md5Checksum)',
    pageSize: 100
  });
  return response.data.revisions;
}
```

**Limitation**: Revision history may be incomplete for frequently edited Google Docs/Sheets/Slides.

### File comments

```javascript
async function getFileComments(fileId) {
  const response = await drive.comments.list({
    fileId,
    fields: 'comments(id, content, author, createdTime, modifiedTime, resolved, replies)',
    includeDeleted: false,
    pageSize: 100
  });
  return response.data.comments;
}
```

## User entity: building from API responses

Google Drive has **no dedicated user listing endpoint**. Users must be extracted from file metadata and permissions.

### User object structure

```javascript
// User appears in owners[], lastModifyingUser, sharingUser, and permission responses
{
  "displayName": "John Doe",
  "emailAddress": "john@example.com",    // May be null if not visible
  "permissionId": "12345678901234567890", // Unique identifier - USE AS PRIMARY KEY
  "photoLink": "https://lh3.googleusercontent.com/...",
  "me": true                              // Whether this is the authenticated user
}
```

### Getting the authenticated user

```javascript
async function getCurrentUser() {
  const response = await drive.about.get({
    fields: 'user(displayName, emailAddress, permissionId, photoLink, me)'
  });
  return response.data.user;
}
```

### Collecting users during sync

```javascript
class UserCollector {
  constructor() {
    this.users = new Map(); // permissionId -> user
  }
  
  addFromFile(file) {
    if (file.owners) {
      file.owners.forEach(u => this.addUser(u));
    }
    if (file.lastModifyingUser?.permissionId) {
      this.addUser(file.lastModifyingUser);
    }
    if (file.sharingUser?.permissionId) {
      this.addUser(file.sharingUser);
    }
  }
  
  addFromPermissions(permissions) {
    permissions
      .filter(p => p.type === 'user')
      .forEach(p => this.users.set(p.id, {
        permissionId: p.id,
        displayName: p.displayName,
        emailAddress: p.emailAddress,
        photoLink: p.photoLink
      }));
  }
  
  addUser(user) {
    if (user.permissionId) {
      this.users.set(user.permissionId, {
        permissionId: user.permissionId,
        displayName: user.displayName || user.emailAddress || 'Unknown',
        emailAddress: user.emailAddress || null,
        photoLink: user.photoLink || null,
        isCurrentUser: user.me === true
      });
    }
  }
  
  getAll() {
    return Array.from(this.users.values());
  }
}
```

## Permissions and sharing information

### Permission types and roles

| Type | Description |
|------|-------------|
| `user` | Individual Google account |
| `group` | Google Group |
| `domain` | All users in a Workspace domain |
| `anyone` | Public (with or without link) |

| Role | My Drive | Shared Drives |
|------|----------|---------------|
| `owner` | ✓ Full control | N/A |
| `organizer` | N/A | ✓ Manage drive |
| `fileOrganizer` | N/A | ✓ Manage content |
| `writer` | ✓ Edit | ✓ Edit |
| `commenter` | ✓ Comment | ✓ Comment |
| `reader` | ✓ View | ✓ View |

### Listing permissions

```javascript
async function getPermissions(fileId) {
  const response = await drive.permissions.list({
    fileId,
    supportsAllDrives: true,
    fields: 'permissions(id, type, role, emailAddress, displayName, domain, expirationTime, deleted, permissionDetails)'
  });
  return response.data.permissions;
}
```

### Detecting inherited permissions (shared drives)

The `permissionDetails` array distinguishes direct vs inherited:

```javascript
// Example permission with both direct and inherited access
{
  "id": "12345",
  "type": "user",
  "role": "writer",
  "permissionDetails": [
    {
      "permissionType": "member",  // From shared drive membership
      "role": "commenter",
      "inherited": true,
      "inheritedFrom": "SHARED_DRIVE_ID"
    },
    {
      "permissionType": "file",    // Direct permission
      "role": "writer",
      "inherited": false
    }
  ]
}
```

## Content extraction from Google Workspace files

### Export format matrix

| Source Type | Best for Text | Alternative | Limitation |
|-------------|---------------|-------------|------------|
| Google Docs | `text/plain`, `text/markdown` | `application/pdf` | 10MB via API |
| Google Sheets | `text/csv` | `.xlsx` for all sheets | CSV = first sheet only |
| Google Slides | `text/plain` | `application/pdf` | Includes speaker notes |
| Google Drawings | `image/svg+xml` | `image/png` | No text extraction |

### Exporting Google Docs

```javascript
async function exportGoogleDoc(fileId, mimeType = 'text/plain') {
  const response = await drive.files.export({
    fileId,
    mimeType
  }, { responseType: 'arraybuffer' });
  
  return Buffer.from(response.data).toString('utf-8');
}

// For large files (>10MB), use exportLinks
async function exportLargeDoc(fileId) {
  const file = await drive.files.get({
    fileId,
    fields: 'exportLinks'
  });
  
  const textExportUrl = file.data.exportLinks['text/plain'];
  // Fetch directly from URL (no 10MB limit)
}
```

### Handling Google Sheets with multiple tabs

The Drive API CSV export only returns the **first sheet**. Use the Sheets API for complete access:

```javascript
const sheets = google.sheets({ version: 'v4', auth });

async function getAllSheetData(spreadsheetId) {
  // Get sheet metadata
  const spreadsheet = await sheets.spreadsheets.get({
    spreadsheetId,
    fields: 'sheets.properties'
  });
  
  const sheetData = {};
  for (const sheet of spreadsheet.data.sheets) {
    const title = sheet.properties.title;
    const values = await sheets.spreadsheets.values.get({
      spreadsheetId,
      range: `'${title}'!A:ZZ`
    });
    sheetData[title] = values.data.values || [];
  }
  
  return sheetData;
}
```

### Google Docs tabs feature

Documents can have **up to 100 tabs** (introduced October 2024). The `files.export` endpoint exports all tabs combined:

```javascript
// Drive API export includes all tabs
const fullContent = await exportGoogleDoc(docId, 'text/plain');

// For structured access, use the Docs API
const docs = google.docs({ version: 'v1', auth });
const document = await docs.documents.get({
  documentId: docId,
  includeTabsContent: true
});

// Traverse tabs
for (const tab of document.data.tabs || []) {
  const tabProperties = tab.tabProperties;
  const documentTab = tab.documentTab;
  // Process each tab's body content
}
```

### Google Workspace MIME types

| Type | MIME Type | Exportable |
|------|-----------|------------|
| Folder | `application/vnd.google-apps.folder` | N/A |
| Document | `application/vnd.google-apps.document` | ✓ |
| Spreadsheet | `application/vnd.google-apps.spreadsheet` | ✓ |
| Presentation | `application/vnd.google-apps.presentation` | ✓ |
| Drawing | `application/vnd.google-apps.drawing` | ✓ |
| Form | `application/vnd.google-apps.form` | ✗ |
| Site | `application/vnd.google-apps.site` | ✗ |
| Shortcut | `application/vnd.google-apps.shortcut` | N/A |
| Apps Script | `application/vnd.google-apps.script` | ✓ (JSON) |

### Downloading binary files

```javascript
async function downloadBinaryFile(fileId) {
  const response = await drive.files.get({
    fileId,
    alt: 'media',
    supportsAllDrives: true
  }, { responseType: 'arraybuffer' });
  
  return Buffer.from(response.data);
}

// Partial download for large files
async function downloadPartial(fileId, startByte, endByte, accessToken) {
  const response = await fetch(
    `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
    {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Range': `bytes=${startByte}-${endByte}`
      }
    }
  );
  return await response.arrayBuffer();
}
```

## Rate limits and quotas

| Quota | Limit |
|-------|-------|
| Queries per 60 seconds | **12,000** |
| Queries per 60 seconds per user | **12,000** |
| Upload per day | 750 GB |

**No daily request limit** as long as per-minute quotas are respected.

### Exponential backoff implementation

```javascript
async function executeWithRetry(apiCall, maxRetries = 5) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await apiCall();
    } catch (error) {
      if (error.code === 403 || error.code === 429) {
        const waitTime = Math.min(
          Math.pow(2, attempt) * 1000 + Math.random() * 1000,
          64000
        );
        console.log(`Rate limited. Retrying in ${waitTime}ms`);
        await new Promise(r => setTimeout(r, waitTime));
      } else {
        throw error;
      }
    }
  }
  throw new Error('Max retries exceeded');
}
```

## Pagination strategy

All list endpoints return paginated results. **Always handle pagination**—default is ~100 results, maximum is 1000.

```javascript
async function paginateAll(listParams) {
  const allResults = [];
  let pageToken = null;
  
  do {
    const response = await drive.files.list({
      ...listParams,
      pageToken,
      pageSize: 1000
    });
    
    allResults.push(...(response.data.files || []));
    pageToken = response.data.nextPageToken;
  } while (pageToken);
  
  return allResults;
}
```

**Include `nextPageToken` in fields parameter**: `fields: 'nextPageToken, files(id, name)'`

## Incremental sync with Changes API

The Changes API enables efficient delta sync by tracking modifications since a stored page token.

### Initial setup

```javascript
async function initializeSync() {
  // 1. Get starting page token
  const tokenResponse = await drive.changes.getStartPageToken({
    supportsAllDrives: true
  });
  const startPageToken = tokenResponse.data.startPageToken;
  
  // 2. Full initial sync
  const allFiles = await paginateAll({
    q: 'trashed = false',
    supportsAllDrives: true,
    includeItemsFromAllDrives: true,
    fields: 'nextPageToken, files(id, name, mimeType, modifiedTime, parents)'
  });
  
  // 3. Store token for future syncs
  return { files: allFiles, pageToken: startPageToken };
}
```

### Processing changes

```javascript
async function getChangesSinceToken(savedPageToken) {
  let pageToken = savedPageToken;
  const changes = [];
  
  while (pageToken) {
    const response = await drive.changes.list({
      pageToken,
      supportsAllDrives: true,
      includeItemsFromAllDrives: true,
      fields: 'nextPageToken, newStartPageToken, changes(fileId, removed, file(id, name, mimeType, modifiedTime, trashed, parents))'
    });
    
    changes.push(...(response.data.changes || []));
    
    if (response.data.newStartPageToken) {
      // End of changes - save this token
      return { changes, newPageToken: response.data.newStartPageToken };
    }
    pageToken = response.data.nextPageToken;
  }
  
  return { changes, newPageToken: savedPageToken };
}
```

### Webhook notifications (push updates)

```javascript
async function setupWebhook(pageToken, webhookUrl) {
  const response = await drive.changes.watch({
    pageToken,
    supportsAllDrives: true,
    requestBody: {
      id: crypto.randomUUID(),
      type: 'web_hook',
      address: webhookUrl,  // Must be HTTPS
      expiration: Date.now() + 86400000  // Max 1 week
    }
  });
  
  return {
    channelId: response.data.id,
    resourceId: response.data.resourceId,
    expiration: response.data.expiration
  };
}

// Handle webhook notification
app.post('/webhook', async (req, res) => {
  const resourceState = req.headers['x-goog-resource-state'];
  
  if (resourceState === 'sync') {
    // Initial sync confirmation
    res.status(200).send();
    return;
  }
  
  // Notification just says "something changed" - fetch actual changes
  const { changes, newPageToken } = await getChangesSinceToken(savedPageToken);
  // Process changes and update savedPageToken
  
  res.status(200).send();
});
```

**Webhook limitations**: Channels expire (max 1 week). Notifications only indicate something changed—always call `changes.list` to get actual modifications.

## Critical API parameters for shared drives

When building an integration that supports **both** personal and shared drives, always include:

| Parameter | Value | Required On |
|-----------|-------|-------------|
| `supportsAllDrives` | `true` | All file/permission operations |
| `includeItemsFromAllDrives` | `true` | `files.list` to include shared drives |
| `corpora` | `'user'`, `'drive'`, or `'allDrives'` | `files.list` for scoping |
| `driveId` | Shared drive ID | Required when `corpora='drive'` |

```javascript
// List files from a specific shared drive
await drive.files.list({
  corpora: 'drive',
  driveId: 'SHARED_DRIVE_ID',
  supportsAllDrives: true,
  includeItemsFromAllDrives: true,
  q: 'trashed = false'
});

// List files from My Drive only
await drive.files.list({
  corpora: 'user',
  supportsAllDrives: true,
  includeItemsFromAllDrives: false,
  q: 'trashed = false'
});
```

## Node.js SDK setup

```bash
npm install googleapis
```

```javascript
const { google } = require('googleapis');

// Initialize with stored tokens
const oauth2Client = new google.auth.OAuth2(
  process.env.CLIENT_ID,
  process.env.CLIENT_SECRET,
  process.env.REDIRECT_URI
);

oauth2Client.setCredentials({
  access_token: storedAccessToken,
  refresh_token: storedRefreshToken,
  expiry_date: storedExpiryDate
});

// Create Drive client
const drive = google.drive({ version: 'v3', auth: oauth2Client });

// Use API v3 (not v2)
// v3 benefits: smaller payloads, better query performance, cleaner field names
```

## API endpoints summary

| Operation | Method | Endpoint |
|-----------|--------|----------|
| Authorization | GET | `https://accounts.google.com/o/oauth2/v2/auth` |
| Token exchange | POST | `https://oauth2.googleapis.com/token` |
| List shared drives | GET | `/drive/v3/drives` |
| Get shared drive | GET | `/drive/v3/drives/{driveId}` |
| List files/folders | GET | `/drive/v3/files` |
| Get file metadata | GET | `/drive/v3/files/{fileId}` |
| Export file content | GET | `/drive/v3/files/{fileId}/export` |
| Download binary | GET | `/drive/v3/files/{fileId}?alt=media` |
| List revisions | GET | `/drive/v3/files/{fileId}/revisions` |
| List comments | GET | `/drive/v3/files/{fileId}/comments` |
| List permissions | GET | `/drive/v3/files/{fileId}/permissions` |
| Get current user | GET | `/drive/v3/about?fields=user` |
| Get start page token | GET | `/drive/v3/changes/startPageToken` |
| List changes | GET | `/drive/v3/changes` |
| Watch changes | POST | `/drive/v3/changes/watch` |

## Common gotchas and quirks

- **Shared drive files have no `owners` field**—the drive itself owns the files
- **`root` alias only works for My Drive**, not shared drives (use shared drive ID as root folder ID)
- **CSV export returns first sheet only**—use Sheets API for multi-tab spreadsheets
- **Export API has 10MB limit**—use `exportLinks` URLs for larger files
- **Revision history incomplete** for frequently edited Workspace files
- **Email addresses may be null** if users haven't made them visible to the requester
- **Page tokens expire**—if `invalid_token` error occurs, perform full resync
- **`incompleteSearch: true`** in response means some results may be missing (use more specific `corpora`)
- **Files can have multiple parents in My Drive** but only one in shared drives
- **Comments API requires `fields` parameter**—it won't return data without explicit field selection

## Conclusion

Building a Fibery integration requires handling four distinct entity types through a unified API that treats personal and shared drives differently. Key success factors include **always setting `supportsAllDrives: true`**, implementing robust pagination and retry logic, using the Changes API for efficient incremental sync, and extracting users from file metadata since no dedicated user listing exists. For content extraction, prefer plain text exports for Workspace files and use specialized APIs (Sheets, Docs, Slides) when full fidelity or structure is needed. The restricted OAuth scope requirement means planning for Google's security review process before production deployment.